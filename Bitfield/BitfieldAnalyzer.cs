// Template file generated by Kari. Feel free to change it or remove this message.
using System;
using System.Collections.Generic;
using System.Diagnostics;
using Kari.GeneratorCore;
using Kari.GeneratorCore.Workflow;
using Microsoft.CodeAnalysis;

namespace Kari.Plugins.Bitfield
{
    // An analyzer will be created per project. 
    // It manages collecting specific information with a single project as input.
    public class BitfieldAnalyzer : IAnalyzer, ISimpleGenerator
    {
        // Keep this public for it to be acessible via the template.
        public readonly List<BitfieldInfo> _infos = new List<BitfieldInfo>();

        public void Collect(ProjectEnvironment environment)
        {
            foreach (var type in environment.TypesWithAttributes)
            {
                if (type.TryGetAttribute(BitfieldSymbols.SpecificationAttribute, environment.Logger, out var attribute))
                {
                    var typeInfo = new BitfieldInfo(type, attribute);
                    if (typeInfo.TryInitializeProperties())
                        _infos.Add(typeInfo);
                }
            }
        }

        public struct ItemLayoutInfo
        {
            public int intIndexStart;
            public int numIntIndices;
            public int bitIndexStart;
        }

        public void AppendBitfieldType(BitfieldInfo info, ref CodeBuilder builder)
        {
            builder.Indent();
            builder.Append($"public ");
            builder.Append(info.Specification.Struct ? "struct " : "class ");
            builder.Append(info.Specification.Name);
            builder.Append(" : ");
            builder.Append(info.Symbol.GetFullyQualifiedName());
            builder.NewLine();
            builder.StartBlock();

            int currentBitIndex = 0;
            int currentIntIndex = 0;
            var layout = new ItemLayoutInfo[info.PropertyInfos.Count];
            for (int i = 0; i < info.PropertyInfos.Count; i++)
            {
                var property = info.PropertyInfos[i];
                // TODO: this can use a more advanced algorithm, aka stuff more things in a single int.
                // This can use some graph search algo.
                // TODO: customize overflow behavior.
                if (property.Length < 32)
                {
                    layout[i].numIntIndices = 0;
                    if (currentBitIndex + property.Length > 32)
                    {
                        currentIntIndex++;
                        layout[i].intIndexStart = currentIntIndex;
                        layout[i].bitIndexStart = 0;
                    }
                    else
                    {
                        layout[i].bitIndexStart = currentBitIndex;
                        layout[i].intIndexStart = currentIntIndex;
                        currentBitIndex += property.Length;
                        if (currentBitIndex == 32)
                        {
                            currentBitIndex = 0;
                            currentIntIndex++;
                        }
                    }
                }
                else if (property.Length == 32)
                {
                    if (currentBitIndex != 0)
                    {
                        currentBitIndex = 0;
                        currentIntIndex++;
                    }
                    layout[i].numIntIndices = 1;
                    layout[i].intIndexStart = currentIntIndex;
                    layout[i].bitIndexStart = 0;
                    currentIntIndex++;
                }
                else
                {
                    layout[i].bitIndexStart = currentBitIndex;
                    layout[i].intIndexStart = currentIntIndex;
                    int numWholeInts = (property.Length + currentBitIndex) / 32;
                    layout[i].numIntIndices = numWholeInts;
                    currentIntIndex += numWholeInts;
                    currentBitIndex = (property.Length + currentBitIndex) % 32;
                }
            }

            int numInts = currentIntIndex;
            if (currentBitIndex > 0)
                numInts++;

            for (int i = 0; i < numInts; i++)
                builder.AppendLine($"private int _int{i};");

            string GetIntText(int index) => "_int" + layout[index].intIndexStart;

            int GetMask(int inclusiveStartBitIndex, int length)
            {
                int num = 0;
                for (int i = 0; i < length; i++)
                {
                    num <<= 1;
                    num |= 1;
                }
                num <<= inclusiveStartBitIndex;
                return num;
            }

            for (int i = 0; i < info.PropertyInfos.Count; i++)
            {
                var property = info.PropertyInfos[i];
                builder.AppendLine($"public {property.FullyQualifiedTypeName} {property.Name}");
                builder.StartBlock();

                // TODO: Allow types that take up more than 4 bytes
                Debug.Assert(layout[i].numIntIndices == 0);

                int mask = GetMask(layout[i].bitIndexStart, property.Length);
                string maskText = "0x" + mask.ToString("x8");
                string _inti = GetIntText(i);

                builder.AppendLine("get");
                builder.StartBlock();
                builder.AppendLine($"int bits = ({_inti} & {maskText}) >> {layout[i].bitIndexStart};");
                string GetCast()
                {
                    if (property.Symbol.Type == Symbols.Bool)
                        return "bits > 0";
                    return $"({property.FullyQualifiedTypeName}) (bits + {property.LowerBound})";
                }
                builder.AppendLine($"return {GetCast()};");
                builder.EndBlock();

                builder.AppendLine("set");
                builder.StartBlock();

                string GetCastIntValue()
                {
                    if (property.Symbol.Type == Symbols.Bool)
                        return "(value ? 1 : 0)";
                    return "((int) value)";
                }
                string intValueTextSet = $"{GetCastIntValue()} - {property.LowerBound}";
                builder.AppendLine($"int bits = (({intValueTextSet}) << {layout[i].bitIndexStart}) & {maskText};");
                builder.AppendLine($"{_inti} = ({_inti} & ~{maskText}) | bits;");
                builder.EndBlock();

                builder.EndBlock();
            }

            builder.EndBlock();
        }

        public string TransformText(ProjectEnvironmentData project) 
        {
            if (_infos.Count == 0) 
                return null;

            var builder = new CodeBuilder("    ");
            builder.Append("namespace ");
            builder.Append(project.GeneratedNamespaceName);
            builder.StartBlock();
            foreach (var info in _infos)
                AppendBitfieldType(info, ref builder);
            builder.EndBlock();

            return builder.ToString();
        }
    }

    public readonly struct BitfieldPropertyInfo
    {
        public readonly IPropertySymbol Symbol;
        public readonly IBitfieldProperty Attribute;
        public readonly string FullyQualifiedTypeName;

        public readonly int Length;
        public string Name => Symbol.Name;
        public readonly int LowerBound;

        public BitfieldPropertyInfo(IPropertySymbol symbol, IBitfieldProperty attribute, int length, int lowerBound)
        {
            Symbol = symbol;
            Attribute = attribute;
            FullyQualifiedTypeName = symbol.Type.GetFullyQualifiedName();
            Length = length;
            LowerBound = lowerBound;
        }
    }

    // Store information in such structs/classes
    public readonly struct BitfieldInfo
    {
        public readonly INamedTypeSymbol Symbol;
        public readonly SpecificationAttribute Specification;
        public readonly List<BitfieldPropertyInfo> PropertyInfos;
        public readonly string FullyQualifiedTypeName;

        public string Name => Specification.Name;

        public BitfieldInfo(INamedTypeSymbol symbol, SpecificationAttribute specification)
        {
            Symbol = symbol;
            Specification = specification;
            PropertyInfos = new List<BitfieldPropertyInfo>();
            FullyQualifiedTypeName = symbol.GetFullyQualifiedName();
    
            if (specification.Name is null)
            {
                string name = symbol.Name;
                if (name[0] == 'I')
                    name = name.Substring(1);
                specification.Name = name;
            }
        }

        public bool IsNumericType(ITypeSymbol type)
        {
            if ((int) type.SpecialType >= (int) SpecialType.System_SByte 
                || type.SpecialType == SpecialType.System_Enum)
            {
                return true;
            }
            return false;
        }

        public bool TryInitializeProperties()
        {
            var logger = new Logger("Bitfield " + Name);
                    
            foreach (var property in Symbol.GetMembers().OfType<IPropertySymbol>())
            {
                IBitfieldProperty propertyAttribute;
                int lowerBound = 0;
                int length = 0;

                if (property.TryGetAttribute(BitfieldSymbols.BitsAttribute, logger, out var bitsAttribute))
                {
                    propertyAttribute = bitsAttribute;
                    if (bitsAttribute.NumBits < 0)
                    {
                        logger.LogError(property.Name + " NumBits must not be < 0");
                    }
                    if (!IsNumericType(property.Type) && property.Type != Symbols.Bool)
                    {
                        logger.LogError(property.Name + " must be a numeric type or a bool");
                    }
                    length = bitsAttribute.NumBits;
                }
                else if (property.TryGetAttribute(BitfieldSymbols.BitAttribute, logger, out var bitAttribute))
                {
                    propertyAttribute = bitAttribute;
                    if (property.Type != Symbols.Bool)
                        logger.LogError(property.Name + " must be a bool in order to take up a single bit. Consider using `Bits` instead");
                    length = 1;
                }
                else if (property.TryGetAttribute(BitfieldSymbols.FlagsAttribute, logger, out var flagsAttribute))
                {
                    propertyAttribute = flagsAttribute;

                    if (property.Type is INamedTypeSymbol enumType && enumType.TypeKind == TypeKind.Enum)
                    {
                        int maxValue = 0;
                        bool isPowerOfTwo(int value)
                        {
                            int count = 0;
                            while (value > 0)
                            {
                                count += value & 1;
                                value >>= 1;
                            }
                            return count > 0;
                        }
                        foreach (var member in enumType.GetMembers().OfType<IFieldSymbol>())
                        {
                            maxValue = Math.Max((int) member.ConstantValue, maxValue);
                        }
                        while (maxValue > 0)
                        {
                            maxValue >>= 1;
                            length++;
                        }
                    }
                    else
                    {
                        logger.LogError("A flag thing must be a flag enum. Otherwise, just use `Bits`");
                    }
                }
                else if (property.TryGetAttribute(BitfieldSymbols.RangeAttribute, logger, out var rangeAttribute))
                {
                    propertyAttribute = rangeAttribute;
                    if (rangeAttribute.End < rangeAttribute.Start)
                        logger.LogError(property.Name + " length must not be < 0");
                    if (!IsNumericType(property.Type))
                        logger.LogError(property.Name + " must be a numeric type");
                    lowerBound = rangeAttribute.Start;
                    if (rangeAttribute.Start != rangeAttribute.End)
                    {
                        int difference = rangeAttribute.End - rangeAttribute.Start;
                        while (difference > 0)
                        {
                            difference >>= 1;
                            length++;
                        }
                    }
                }
                else
                {
                    continue;
                }

                PropertyInfos.Add(new BitfieldPropertyInfo(property, propertyAttribute, length, lowerBound));
            }

            return true;
        }
    }
}
