// Template file generated by Kari. Feel free to change it or remove this message.
// This file should be included almost as-is in the generated output.
// The text version of this file and the helpers for the attributes defined here are available in the
// BitfieldAnnotations.Generated.cs version of this file.
namespace Kari.Plugins.Bitfield
{
    // It is important to import things inside the namespace.
    // Obviously, you cannot import Kari specific things or things defined in your other files, 
    // unless you also export the source code from those files.
    using System;
    using System.Diagnostics;


    /// <summary>
    /// Marks the given interface as a specification for to-be-generated bitfield type.
    /// Bitfield struct will minimize the amount of memory used for numbers, by grouping them
    /// together in a single (or a few) ints. They are retrieved from that int by using bit operations.
    /// To be more precise, bit shifts, ands and ors.
    /// </summary>
    [AttributeUsage(AttributeTargets.Interface)]
    [Conditional("CodeGeneration")]
    public class SpecificationAttribute : Attribute
    {
        public string Name;
        public SpecificationAttribute(string name)
        {
            Name = name;
        }

        public bool Struct { get; set; } = true;
        public bool DynamicallySized => false;
    }

    public interface IBitfieldProperty
    {
    }

    /// <summary>
    /// Specifies the number of its the given number will take up.
    /// The number must be of one of the integer value types.
    /// Should be used on properties inside a bitfield specification (interface).
    /// </summary>
    [AttributeUsage(AttributeTargets.Property)]
    [Conditional("CodeGeneration")]
    public class BitsAttribute : Attribute, IBitfieldProperty
    {
        public int NumBits;
        public BitsAttribute(int numBits)
        {
            NumBits = numBits;
        }
    }

    /// <summary>
    /// Used to mark a boolean value that would take up a single bit.
    /// Should be used on properties inside a bitfield specification (interface).
    /// </summary>
    [AttributeUsage(AttributeTargets.Property)]
    [Conditional("CodeGeneration")]
    public class BitAttribute : Attribute, IBitfieldProperty
    {
    }

    /// <summary>
    /// Used to mark an enum to be used as flag source.
    /// Should be used on properties inside a bitfield specification (interface).
    /// </summary>
    [AttributeUsage(AttributeTargets.Property)]
    [Conditional("CodeGeneration")]
    public class FlagsAttribute : Attribute, IBitfieldProperty
    {
    }
    
    /// <summary>
    /// Marks a range of values.
    /// Should be used on properties inside a bitfield specification (interface).
    /// </summary>
    [AttributeUsage(AttributeTargets.Property)]
    [Conditional("CodeGeneration")]
    public class RangeAttribute : Attribute, IBitfieldProperty
    {
        /// Inclusive
        public int Start;
        /// Exclusive
        public int End;

        public RangeAttribute(int start, int end)
        {
            Start = start;
            End = end;
        }
    }

    /// <summary>
    /// The given field will take up the rest of the int it's found in
    /// TODO: Control min and max.
    /// I have an even better idea (probably). 
    /// Inherit all attributes off of a single attribute with all possible things in it.
    /// Then just query that attribute.
    /// </summary>
    [AttributeUsage(AttributeTargets.Property)]
    [Conditional("CodeGeneration")]
    public class RestAttribute : Attribute, IBitfieldProperty
    {
        public int Minimum = -1;
        public int Maximum = -1;
    }
}
